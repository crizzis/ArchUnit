ext {
    addTestJarTo = { proj ->
        proj.with {
            configurations {
                tests.extendsFrom testRuntime
            }

            task testJar(type: Jar) {
                archiveClassifier = 'tests'
                from sourceSets.test.output
            }

            artifacts {
                tests testJar
            }
        }
    }

    configureSlowTestsFor = { proj ->
        proj.afterEvaluate { projAfterEvaluate ->
            projAfterEvaluate.tasks.withType(Test) {
                if (!project.hasProperty('allTests')) {
                    useJUnit {
                        excludeCategories 'com.tngtech.archunit.Slow'
                    }
                }
            }
        }
    }
}

configure(subprojects.findAll { it.name != 'docs' }) {
    afterEvaluate { project ->
        project.tasks.withType(Test) {
            maxHeapSize = "2G"

            testLogging {
                events "failed"
                exceptionFormat "full"
            }

            ignoreFailures = project.hasProperty('ignoreTestFailures')
        }
    }
}

// Add some better test failure reporting on the console

List<TestFailureReport> testReports = []
configure(subprojects.findAll { it.name != 'docs' }) {
    TestFailureReport testReport = new TestFailureReport(project: name)
    testReports << testReport

    afterEvaluate { project ->
        project.tasks.withType(Test) {
            afterTest { TestDescriptor descriptor, TestResult result ->
                if (result.resultType == TestResult.ResultType.FAILURE) {
                    testReport.addFailure(new TestFailure(descriptor, result.exception))
                }
            }
        }
    }
}

gradle.buildFinished {
    testReports.each { it.printFailures() }
}

class TestFailureReport {
    String project
    private Map<String, TestClassFailureReport> reports = [:].withDefault { testClassName -> new TestClassFailureReport(className: testClassName) }

    void addFailure(TestFailure testFailure) {
        reports[testFailure.className].testFailures << testFailure
    }

    void printFailures() {
        def failureReports = reports.values().findAll { !it.testFailures.empty }
        if (failureReports.empty) {
            return
        }

        String redX = "\033[1;31m\u2718 \033[0m"
        String heading = "Failed tests for ${project}"
        int headingBoxWidth = heading.length() + 4
        println """
        ${'-' * headingBoxWidth}
        | ${heading} |
        ${'-' * headingBoxWidth}
        """.stripIndent()
        failureReports.each { TestClassFailureReport failureReport ->
            println "- ${failureReport.className} --> ${failureReport.location}"
            failureReport.testFailures.each { TestFailure failure ->
                println "  ${redX}.${failure.testDescription} --> ${failure.location}"
            }
        }
        println "${'-' * headingBoxWidth}"
    }
}

class TestClassFailureReport {
    String className
    List<TestFailure> testFailures = []

    String getLocation() {
        return "(${className.replaceAll(/.*\./, '')}.java:0)"
    }
}

class TestFailure {
    String className
    String testDescription
    String location = 'Unknown'

    TestFailure(TestDescriptor descriptor, Throwable failure) {
        className = descriptor.className
        testDescription = descriptor.displayName
        failure?.stackTrace?.find { it.className == className }?.each {
            location = "(${it.fileName}:${it.lineNumber})"
        }
    }
}
